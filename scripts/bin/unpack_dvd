#!/usr/bin/ruby

#
# This script unpacks either an ISO image or a DVD to the specified directory
# or /srv/www/yum/ (default).
#
# It uses the 'isoinfo' utility to pull files off of the DVD so no root access
# is requried for locally unpacking an ISO.
#

require 'rubygems'
require 'optparse'
require 'fileutils'
require 'find'
require 'open3'

File.umask(0022)

# This class shamelessly borrowed from
# http://www.software-testing.com.au/blog/2010/01/13/text-based-progress-bar-in-ruby-for-command-line-programs/
class ProgressBar

  attr_accessor :items_to_do, :items_done

  def initialize(items_to_do, items_done=0)
    reset(items_to_do, items_done)
  end

  def percent_complete
    return (@items_complete*1.0/@items_to_do*1.0)*100
  end

  def advance(steps_to_advance=1)
    @items_complete+=steps_to_advance
  end

  def reset(items_to_do, items_done=0)
    @items_to_do=items_to_do
    @items_complete=items_done
  end

  def report
    $stdout.print "\r#{progress_bar} #{@items_complete} of #{@items_to_do} done"
  end

  def percent_report
    $stdout.print "\r#{progress_bar} #{percent_complete.round}%"
  end

  def progress_bar
    complete_bar=(percent_complete/2.0).floor
    incomplete_bar=((100-percent_complete)/2.0).ceil
    return "[#{"*"*complete_bar}#{"-"*incomplete_bar}]"
  end
end

def update_yum_repo(repo)
  puts "Updating repo at #{repo}"
  FileUtils.mkdir_p(repo,{:mode => 0755})
  Dir.chdir(repo) do
    Find.find('../') do |path|
      Find.prune if File.basename(path) == File.basename(repo)

      if File.basename(path) =~ /.*\.rpm/ and not File.symlink?(File.basename(path)) then
        FileUtils.ln_sf(path,File.basename(path))
      end
    end

    # This code is hideous.
    # It parses the output of the createrepo command and then reprints it as a
    # percentage so that the user knows that something is happening. Without
    # this, it simply sits there and looks like it has hung.
    buffer = ''
    first = true
    IO.popen("createrepo -p --update .").each_byte do |b|
      b = b.chr
      if b == "\r" or b == "\n" then
        next if buffer =~ /^\s*$/

        if buffer =~ /(\d+)\/(\d+).*\.rpm/ then
          print "\r#{((($1.to_f/$2.to_f) * 100) * 100).round.to_f / 100}% Complete"
        else
          if first then
            puts ''
            first = false
          end
          puts buffer
        end
        buffer = ''
      else
        buffer << b
      end
    end
  end

  begin
    FileUtils.chown_R('root','apache',repo)
  rescue Exception => e
    $stderr.puts("Warning: Could not change permissions on #{repo} to 'root:apache'.")
    $stderr.puts(e)
  end

  if Process.uid == 0
    begin
      if Gem::Version.new(RUBY_VERSION) < Gem::Version.new('1.9')
        # Use Puppet to hack around the lack of symbolic modes in Ruby < 1.9
        system(%{puppet resource file #{repo} recurse=true mode='g+srX' 2>&1 > /dev/null})
      else
        FileUtils.chmod_R('g+srX',repo)
      end
    rescue Exception => e
      $stderr.puts("Warning: Could not change permissions on #{repo} to 'g+srX'.")
      $stderr.puts(e)
    end
  end
end

options = Hash.new
opts = OptionParser.new do |opts|
  opts.banner = "Usage: #{$0} [options] /path/to/dvd/to/unpack"

  if File.directory?('/var/www/yum')
    options[:dest] = '/var/www/yum'
  elsif File.directory?('/srv/www/yum')
    options[:dest] = '/srv/www/yum'
  end

  opts.on("-d", "--dest DIR", "The DVD extraction target directory.",
    "  The directory structure <OS>/<version>/<arch>",
    "  will be created under here.") do |dest|
    options[:dest] = dest.chomp
  end

  opts.on("-h", "--help", "Output a useful help message") do
    puts opts
    exit
  end
end

opts.parse!

# Option checking
if not ARGV.length > 0 then
  $stderr.puts("Error: You must pass the path to an ISO to unpack\n\n#{opts}")
  exit 1
end
fail("Could not find a SIMP default output directory and no --dest option provided") unless options[:dest]
fail("Destination directory does not exist") if not File.directory?(options[:dest])

discattrs = {
  :family => nil,
  :version => nil,
  :arch => nil,
  :path => nil
}

discattrs[:path] = ARGV.first
if not File.readable?(discattrs[:path]) then
  $stderr.puts("Error: Could not read file #{discattrs[:path]}")
  exit 1
end

if File.directory?(discattrs[:path]) then
  $stderr.puts("Error: #{discattrs[:path]} is a directory...")
  exit 1
end

isoinfo = "isoinfo -i #{discattrs[:path]}"
if File.blockdev?(discattrs[:path]) then
  isoinfo = "isoinfo dev=#{discattrs[:path]}"
end

# Extract the .treeinfo file from the disc and parse out the relevant values.
%x{#{isoinfo} -R -x /.treeinfo}.each_line do |line|
  if line =~ /^family = (.*)$/ then
      fam = $1.chomp
      if fam.chomp =~ /CentOS/ then
        discattrs[:family] = "CentOS"
      elsif fam.chomp =~ /Red Hat|RHEL|RedHat/ then
        discattrs[:family] = "RedHat"
      end
  elsif line =~ /^version = (.*)$/ then
    discattrs[:version] = $1.chomp
  elsif line =~ /^arch = (.*)$/ then
    discattrs[:arch] = $1.chomp
  end
end

# If everything isn't filled, die a slow death.
discattrs.each_pair do |k,v|
  if v.nil? then
    $stderr.puts("Error: Was not able to find the value for #{k} in the DVD .treeinfo file.")
    exit 1
  end
end

puts "Starting to unpack #{discattrs[:path]}:"

iso_list = %x{#{isoinfo} -Rl}.split("\n")

iso_toc = []

current_dir = nil
iso_list.each do |line|
  if line =~ /Directory listing of (.*)/
    current_dir = $1.strip
    next
  end

  if (line !~ /->/) and (line =~ /^\S{10}\s/)
    file = line.split.last.strip
    next if file =~ /^\/?\.+$/
    iso_toc << "#{current_dir + file}"
  end
end

kill_dirs = iso_toc.map{ |x| File.dirname( x ) }.uniq
iso_toc = iso_toc - kill_dirs

progress = ProgressBar.new(iso_toc.size)


destdir = "#{options[:dest]}/#{discattrs[:family]}/#{discattrs[:version]}/#{discattrs[:arch]}/"
simpdir = "#{options[:dest]}/SIMP/#{discattrs[:arch]}/"

iso_toc.each do |iso_entry|
  if iso_entry =~ /^\/SIMP/
    target = "#{simpdir}#{File.basename(iso_entry)}"
  else

    target = "#{destdir}#{iso_entry}"
  end
  begin
    FileUtils.mkdir_p(File.dirname(target))
  rescue Exception => e
    puts "This is iso_toc: #{iso_entry}"
    puts "This is the target: #{target}"
    puts "This is the target dirname: #{File.dirname(target)}"
  end
  system("#{isoinfo} -R -x #{iso_entry} > #{target}")
  progress.advance
  progress.report
end

puts "Unpacking complete, updating yum repositories...."
update_yum_repo("#{destdir}/Updates")
update_yum_repo(simpdir) unless (simpdir == destdir)
puts "Repo creation complete"

Dir.chdir("#{options[:dest]}/#{discattrs[:family]}") do
  base_ver = discattrs[:version].split('.').first
  if base_ver != discattrs[:version] then
    from = discattrs[:version]
    to = base_ver
    puts "Linking #{from} to #{to}"
    FileUtils.rm(to) if File.symlink?(to)
    FileUtils.ln_sf(from,to)
  end
end

puts "Unpacking of #{discattrs[:path]} complete!"

exit
